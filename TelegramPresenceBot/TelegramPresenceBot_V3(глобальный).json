{
  "scenarioTemplate": {
    "name": "TelegramPresenceBot_V3",
    "desc": "",
    "active": true,
    "onStart": false,
    "sync": false,
    "data": "// Глобальный сценарий: TelegramPresenceBot\n// Этот скрипт определяет присутствие пользователей дома или вне дома через Telegram.\n// Обрабатывает сообщения и управляет выключателями, синхронизируя их с датчиками присутствия.\n// Например: \"Вася arrived\" включает выключатель, отвечает \"Вася дома\", \"Вася left\" — \"Вася не дома\".\n \n// === Настройки чата и бота ===\n// Впиши сюда ID группы \"Семья\", куда бот будет отправлять ответы.\n// Узнать ID чата можно через @RawDataBot в Telegram (отправь /start и посмотри в ответе chat_id).\n// Можно менять: заменяй '***твой_ид_группы***' на ID твоей группы. Если групп несколько, добавляй новые ID в массив, например: ['-1009999999999', '-1008888888888'].\nlet chatIDs = ['***твой_ид_группы***']; // Твой ID группы \"Семья\"\n\n// Впиши сюда токен твоего бота, полученный от @BotFather в Telegram.\n// Это секретный ключ, не делись им с другими! Сохраняй его в безопасности.\n// Можно менять: вставь свой токен вместо '***твой_токен***'.\nlet token = '***твой_токен***'; // Твой токен\n\n// Устанавливает начальное время для обработки сообщений (минус 48 часов от текущего времени).\n// Можно менять: измени 48 на меньшее число (например, 24), если хочешь видеть команды за меньший период.\nlet startTime = Math.floor(Date.now() / 1000) - 48 * 3600; // Начало времени минус 48 часов\n\n// Уникальный номер для логов, увеличивается автоматически при каждом действии.\n// Используем сохранённое значение или 0, чтобы сохранить последовательность логов между перезапусками.\n// Нельзя менять: это нужно для корректной работы логов и отслеживания последовательности.\nlet logId = GlobalVariables.logId || 0;\nGlobalVariables.logId = logId; // Сохраняем текущее значение\n\n// Флаг, показывающий, работает ли цикл tgWatch.\n// Нельзя менять: используется для предотвращения параллельных запусков.\nGlobalVariables.tg_loop_running = GlobalVariables.tg_loop_running || false;\n\n// Хранит идентификатор текущего таймера для цикла.\n// Нельзя менять: нужно для управления циклом.\nGlobalVariables.tg_loop = null;\n\n// Время последнего сброса задач (в секундах от эпохи).\n// Нельзя менять вручную: обновляется автоматически.\nGlobalVariables.tg_last_reset = 0;\n\n// Смещение для получения новых сообщений от Telegram API.\n// Нельзя менять вручную: обновляется автоматически, но можно сбросить через код.\nGlobalVariables.__tg_offset = GlobalVariables.__tg_offset || 0;\n\n// Функция для отправки сообщений в Telegram.\n// Используется для формирования и отправки ответов (например, \"Галя дома\").\n// Нельзя менять: это базовая функция для работы с API Telegram.\nfunction tg() {\n    let chats = [];\n    let messages = [];\n    let silent = false;\n\n    var builder = {\n        line: function(text) {\n            messages.push(text); // Добавляет текст сообщения в очередь\n            return builder;\n        },\n        silent: function(enabled) {\n            silent = enabled !== undefined ? enabled : true; // Включает/выключает уведомления\n            return builder;\n        },\n        send: function() {\n            if (!chats.length) chats = chatIDs; // Если чатов нет, использует заданные chatIDs\n            chats.forEach(function(chatID) {\n                try {\n                    log.info(\"[\" + logId++ + \"] Sending message to chat: \" + chatID + \" at \" + new Date().toISOString());\n                    let request = HttpClient.POST(\"https://api.telegram.org\")\n                        .path(\"bot\" + token)\n                        .path('sendMessage')\n                        .queryString('chat_id', chatID)\n                        .queryString('text', messages.join(\" \\r\\n\"))\n                        .queryString(\"parse_mode\", \"Markdown\")\n                        .queryString(\"disable_notification\", silent);\n                    request.send();\n                } catch (e) {\n                    log.error(\"[\" + logId++ + \"] Send error: \" + e.message);\n                }\n            });\n        }\n    };\n    return builder;\n}\n\n// Основная функция циклической проверки сообщений из Telegram.\n// Запускает цикл с интервалом 5 секунд и обрабатывает команды.\n// Нельзя менять: это основная логика сценария.\nfunction tgWatch() {\n    // Проверяем и устанавливаем глобальный флаг, чтобы избежать параллельных запусков.\n    if (GlobalVariables.tg_loop_running) {\n        log.info(\"[\" + logId++ + \"] tgWatch is already running, skipping start at \" + new Date().toISOString());\n        return;\n    }\n    GlobalVariables.tg_loop_running = true;\n\n    if (GlobalVariables.tg_loop) {\n        clearInterval(GlobalVariables.tg_loop);\n        GlobalVariables.tg_loop = null;\n    }\n\n    // Массив для хранения обработанных update_id с меткой времени.\n    // Используется для предотвращения дублирования сообщений.\n    // Нельзя менять: это нужно для корректной обработки уникальных сообщений.\n    GlobalVariables.processedUpdates = GlobalVariables.processedUpdates || {};\n\n    let loop = function() {\n        let now = Math.floor(Date.now() / 1000);\n        if (now - GlobalVariables.tg_last_reset >= 3600) {\n            GlobalVariables.__tg_offset = 0; // Сброс смещения каждые 60 минут\n            GlobalVariables.tg_last_reset = now;\n            log.info(\"[\" + logId++ + \"] Task reset performed at \" + new Date().toISOString());\n            // Очистка старых обработанных update_id (старше 1 часа).\n            // Это нужно, чтобы не накапливать устаревшие данные.\n            for (let id in GlobalVariables.processedUpdates) {\n                if (now - GlobalVariables.processedUpdates[id] > 3600) {\n                    delete GlobalVariables.processedUpdates[id];\n                }\n            }\n        }\n\n        let offset = GlobalVariables.__tg_offset;\n        let body = HttpClient.GET(\"https://api.telegram.org\")\n            .path(\"bot\" + token)\n            .path('getUpdates')\n            .queryString('offset', offset)\n            .send()\n            .getBody();\n        if (!body) {\n            log.error(\"[\" + logId++ + \"] No response from Telegram API, body is null\");\n            // Задержка 10 секунд перед следующей попыткой.\n            // Это снижает нагрузку на API в случае сбоев.\n            clearInterval(GlobalVariables.tg_loop);\n            GlobalVariables.tg_loop = setTimeout(() => {\n                GlobalVariables.tg_loop = setInterval(loop, 5000);\n            }, 10000);\n            return;\n        }\n        try {\n            let response = JSON.parse(body);\n            let updates = response.result || [];\n            updates.forEach(function(r) {\n                let updateId = r.update_id;\n                if (updateId < offset) return;\n                // Проверка, не обработан ли уже этот update_id.\n                // Это предотвращает повторную обработку одного и того же сообщения.\n                if (GlobalVariables.processedUpdates[updateId]) return;\n                GlobalVariables.__tg_offset = updateId + 1;\n\n                if (!r.message) return;\n\n                let chatId = r.message.chat.id.toString();\n                if (chatId !== chatIDs[0]) return;\n\n                let messageTime = r.message.date;\n                if (messageTime < startTime || (now - messageTime) > 600) { // Игнорировать сообщения старше 10 минут\n                    log.warn(\"[\" + logId++ + \"] Message too old, ignoring: \" + r.message.text);\n                    return;\n                }\n\n                let forwardFromChat = r.message.forward_from_chat || {};\n                if (forwardFromChat && forwardFromChat.type === \"channel\") {\n                    let messageText = r.message.text ? r.message.text.trim() : '';\n                    let senderTitle = forwardFromChat.title || \"unknown\";\n                    log.info(\"[\" + logId++ + \"] Received forwarded message from channel: '\" + messageText + \"', Sender: \" + senderTitle);\n\n                    let parts = messageText.split(' ');\n                    if (parts.length >= 2) {\n                        let name = parts[0];\n                        let command = parts[1].toLowerCase();\n\n                        // === Настройки пользователей и аксессуаров ===\n                        // Здесь указаны имена пользователей и их аксессуары (выключатели).\n                        // serviceId (16) и characteristicId (18) для выключателя фиксированы.\n                        // Синхронизация с датчиком присутствия выполняется через настройки \"Связь с устройством\" в Sprut.Hub.\n                        // Можно менять: добавляй новых пользователей в объект switchMap или удаляй ненужных.\n                        // Как добавлять нового пользователя: добавь новую строку, например: 'Олег': { accessoryId: 183 }.\n                        // Как удалить пользователя: удали строку с ненужным именем.\n                        // Где менять accessoryId: замени значение на ID нового аксессуара, если пользователь связан с другим устройством.\n                        const switchMap = {\n                            'Вася': { accessoryId: 179 }, // Вася, её аксессуар (выключатель)\n                            'Толя': { accessoryId: 180 }, // Толя, её аксессуар\n                            'Лена': { accessoryId: 181 }, // Лена, её аксессуар\n                            'Галя': { accessoryId: 182 }    // Галя, его аксессуар\n                            // Пример добавления: 'Олег': { accessoryId: 183 }\n                        };\n\n                        if (switchMap[name]) {\n                            let switchAccessory = Hub.getAccessory(switchMap[name].accessoryId);\n                            if (switchAccessory) {\n                                let switchService = switchAccessory.getService(16);\n                                if (switchService) {\n                                    let onCharacteristic = switchService.getCharacteristic(18);\n                                    if (onCharacteristic) {\n                                        let switchState = command === \"arrived\"; // true для arrived, false для left\n                                        onCharacteristic.setValue(switchState);\n                                        if (command === \"arrived\") {\n                                            tg().line(name + \" дома\").send();\n                                        } else if (command === \"left\") {\n                                            tg().line(name + \" не дома\").send();\n                                        }\n                                        log.info(\"[\" + logId++ + \"] Switch processed for \" + name);\n                                    } else {\n                                        log.error(\"[\" + logId++ + \"] Characteristic 18 not found for service 16 on accessory \" + switchMap[name].accessoryId);\n                                    }\n                                } else {\n                                    log.error(\"[\" + logId++ + \"] Service 16 not found for accessory \" + switchMap[name].accessoryId);\n                                }\n                            } else {\n                                log.error(\"[\" + logId++ + \"] Accessory \" + switchMap[name].accessoryId + \" not found\");\n                            }\n                        } else {\n                            log.error(\"[\" + logId++ + \"] Unknown name: \" + name);\n                        }\n                    } else {\n                        log.warn(\"[\" + logId++ + \"] Message format invalid, expected 'Name command', got: \" + messageText);\n                    }\n                }\n                // Отмечаем update_id как обработанный.\n                // Это нужно, чтобы не обрабатывать одно и то же сообщение повторно.\n                GlobalVariables.processedUpdates[updateId] = now;\n            });\n        } catch (e) {\n            log.error(\"[\" + logId++ + \"] Error parsing API response: \" + e.message);\n        }\n    };\n\n    GlobalVariables.tg_loop = setInterval(loop, 5000); // Проверяет каждые 5 секунд\n    log.info(\"[\" + logId++ + \"] tgWatch started with interval at \" + new Date().toISOString());\n    // Нельзя менять: интервал 5 секунд важен для своевременной обработки сообщений.\n}\n\n/* \n// Блочный триггер (вставить в блочный сценарий с триггером \"Каждые 5 минут\")\n// Нельзя менять: это обеспечивает запуск tgWatch с заданным интервалом.\nif (!GlobalVariables.tg_loop_running) {\n    global.tgWatch();\n}\n*/",
    "type": "GLOBAL"
  }
}
