{
  "scenarioTemplate": {
    "name": "TelegramPresenceBot",
    "desc": "",
    "active": true,
    "onStart": false,
    "sync": false,
    "data": "// Глобальный сценарий: TelegramPresenceBot\n// Этот скрипт отслеживает присутствие пользователей дома или вне дома через Telegram.\n// Обрабатывает сообщения вида \"Имя arrived\" или \"Имя left\" из канала, управляет выключателями и отправляет уведомления в группу.\n// Например: \"Толя arrived\" включает выключатель и отправляет \"Толя дома\", \"Толя left\" — \"Толя не дома\".\n// Основан на Telegram Bot API (см. документацию: https://core.telegram.org/bots/api).\n\n// === Настройки чата и бота ===\n// ID канала, откуда приходят сообщения (например, \"ProxyFamily\").\n// Узнать ID канала можно через @RawDataBot в Telegram (отправьте /start и посмотрите chat_id в ответе).\n// Можно менять: замените '***твой_ид_канала***' на ID вашего канала. Убедитесь, что бот добавлен в канал с правами чтения.\nlet sourceChatID = '***твой_ид_канала***'; // ID канала, откуда приходят сообщения\n\n// ID группы или групп, куда бот будет отправлять ответы (например, \"Семья\").\n// Можно менять: замените '***твой_ид_группы***' на ID вашей группы. Для нескольких групп добавьте новые ID в массив, например: ['-1007777777777', '-100555555555'].\nlet replyChatIDs = ['***твой_ид_группы***']; // ID группы \"Семья\" для ответов\n\n// Токен бота, полученный от @BotFather в Telegram после регистрации бота.\n// Это секретный ключ, не делитесь им! Храните в безопасном месте (например, в переменной окружения).\n// Можно менять: вставьте свой токен вместо '***твой_токен***'. Если токен неверный, бот не сможет работать.\nlet token = '***твой_токен***'; // Токен бота\n\n// Начальное время для обработки сообщений (минус 48 часов от текущего времени).\n// Определяет, какие сообщения считаются \"слишком старыми\" и игнорируются (например, старше 48 часов).\n// Можно менять: измените 48 на другое значение (например, 24 для 24 часов), если нужен другой период обработки.\nlet startTime = Math.floor(Date.now() / 1000) - 48 * 3600; // Начало времени минус 48 часов\n\n// Уникальный номер для логов, увеличивается автоматически при каждом действии.\n// Используется для отслеживания последовательности событий в логах.\n// Нельзя менять: это нужно для корректной работы логов и их читаемости. После отладки можно закомментировать увеличение logId.\nlet logId = GlobalVariables.logId || 0;\nGlobalVariables.logId = logId; // Сохраняем текущее значение\n\n// Флаг, показывающий, работает ли цикл tgWatch.\n// Используется для предотвращения параллельных запусков цикла.\n// Нельзя менять: это часть механизма управления циклом. После отладки можно оставить без изменений.\nGlobalVariables.tg_loop_running = GlobalVariables.tg_loop_running || false;\n\n// Флаг блокировки для защиты от параллельных запусков.\n// Используется для синхронизации при одновременном срабатывании триггеров.\n// Нельзя менять: это часть защиты от конфликтов. Оставьте как есть.\nGlobalVariables.tg_lock = GlobalVariables.tg_lock || false;\n\n// Хранит идентификатор текущего таймера для цикла tgWatch.\n// Используется для управления и очистки цикла при перезапуске.\n// Нельзя менять: нужно для корректной работы цикла. Оставьте без изменений.\nGlobalVariables.tg_loop = null;\n\n// Время последнего сброса задач (в секундах от эпохи).\n// Используется для периодической очистки старых данных в processedUpdates.\n// Нельзя менять вручную: обновляется автоматически. После отладки можно оставить.\nGlobalVariables.tg_last_reset = GlobalVariables.tg_last_reset || 0;\n\n// Время последней активности цикла (в секундах от эпохи).\n// Используется для проверки зависаний (перезапуск при отсутствии активности более 2 минут).\n// Нельзя менять вручную: обновляется автоматически. После отладки можно оставить.\nGlobalVariables.tg_last_active = GlobalVariables.tg_last_active || 0;\n\n// Смещение для получения новых сообщений от Telegram API.\n// Определяет, с какого update_id начинать запрашивать новые сообщения.\n// Нельзя менять вручную: обновляется автоматически при обработке обновлений.\nGlobalVariables.__tg_offset = GlobalVariables.__tg_offset || 0;\n\n// Объект для хранения обработанных update_id с меткой времени.\n// Предотвращает повторную обработку сообщений.\n// Нельзя менять структуру: добавляйте только через код. После отладки можно оптимизировать очистку.\nGlobalVariables.processedUpdates = GlobalVariables.processedUpdates || {};\n\n// Функция для отправки сообщений в Telegram.\n// Формирует и отправляет ответы в указанные чаты (например, \"Вася дома\") через Bot API.\n// Нельзя менять: это базовая функция для взаимодействия с Telegram. Оставьте как есть.\nfunction tg() {\n    let chats = [];\n    let messages = [];\n    let silent = false;\n\n    var builder = {\n        line: function(text) {\n            messages.push(text); // Добавляет текст сообщения в очередь для отправки\n            return builder;\n        },\n        silent: function(enabled) {\n            silent = enabled !== undefined ? enabled : true; // Включает/выключает уведомления (true — без звука)\n            return builder;\n        },\n        send: function() {\n            if (!chats.length) chats = replyChatIDs; // Использует replyChatIDs, если чаты не указаны\n            chats.forEach(function(chatID) {\n                try {\n                    // Лог отправки сообщения в чат с ID и временем. (Для чего: Проверяет отправку сообщений.)\n                    //log.info(\"[\" + logId++ + \"] Sending message to chat: \" + chatID + \" at \" + new Date().toISOString()); \n                    let request = HttpClient.POST(\"https://api.telegram.org\")\n                        .path(\"bot\" + token)\n                        .path('sendMessage')\n                        .queryString('chat_id', chatID)\n                        .queryString('text', messages.join(\" \\r\\n\"))\n                        .queryString(\"parse_mode\", \"Markdown\")\n                        .queryString(\"disable_notification\", silent);\n                    request.send();\n                } catch (e) {\n                    log.error(\"[\" + logId++ + \"] Send error: \" + e.message); // Лог ошибок отправки\n                }\n            });\n        }\n    };\n    return builder;\n}\n\n// Основная функция циклической проверки сообщений из Telegram.\n// Запускает цикл с интервалом 5 секунд для обработки новых сообщений через getUpdates.\n// Обрабатывает команды вида \"Имя arrived\" или \"Имя left\" и управляет выключателями.\nfunction tgWatch() {\n    // Проверяем блокировку перед запуском\n    // Предотвращает параллельные запуски при одновременном срабатывании триггеров\n    if (GlobalVariables.tg_lock) {\n        log.warn(\"[\" + logId++ + \"] tgWatch is locked, skipping start at \" + new Date().toISOString());\n        return;\n    }\n    GlobalVariables.tg_lock = true;\n    // Лог получения блокировки и запуск tgWatch с состоянием флага. (Для чего: Подтверждает запуск цикла.)\n    //log.info(\"[\" + logId++ + \"] Acquired tg_lock, starting tgWatch, tg_loop_running: \" + (GlobalVariables.tg_loop_running || \"undefined\"));\n\n    // Принудительное завершение старого процесса\n    if (GlobalVariables.tg_loop) {\n        clearInterval(GlobalVariables.tg_loop);\n        GlobalVariables.tg_loop = null;\n        // Лог Очистки старого таймера tg_loop с временем. (Для чего: Проверяет завершение старых циклов.)\n        //log.info(\"[\" + logId++ + \"] Forced cleanup of old tg_loop timer at \" + new Date().toISOString());\n    }\n    if (GlobalVariables.tg_loop_running) {\n        GlobalVariables.tg_loop_running = false;\n        // Лог сброса флага tg_loop_running с временем. (Для чего: Подтверждает сброс флага.)\n        //log.info(\"[\" + logId++ + \"] Forced reset of tg_loop_running at \" + new Date().toISOString());\n    }\n\n    // Сбрасываем смещение для получения новых сообщений\n    // Нельзя менять: это гарантирует обработку всех обновлений после перезапуска\n    GlobalVariables.__tg_offset = 0;\n    // Лог сброса смещения __tg_offset с временем. (Для чего: Проверяет начальное получение обновлений.)\n    //log.info(\"[\" + logId++ + \"] Reset __tg_offset to 0 at \" + new Date().toISOString());\n\n    // Сброс logId при превышении порога\n    // Предотвращает слишком большие значения для удобства чтения логов\n    if (logId > 100000) {\n        logId = 0;\n        GlobalVariables.logId = 0;\n        // Лог сброса logId до 0 с временем. (Для чего: Поддерживает читаемость логов.)\n        //log.info(\"[\" + logId++ + \"] logId reset to 0 at \" + new Date().toISOString());\n    }\n\n    // Устанавливаем флаг запуска\n    GlobalVariables.tg_loop_running = true;\n\n    // Основной цикл проверки сообщений\n    let loop = function() {\n        if (!GlobalVariables.tg_loop_running) {\n            log.warn(\"[\" + logId++ + \"] tg_loop_running is false, stopping loop at \" + new Date().toISOString());\n            clearInterval(GlobalVariables.tg_loop);\n            GlobalVariables.tg_loop = null;\n            GlobalVariables.tg_lock = false;\n            return;\n        }\n\n        let now = Math.floor(Date.now() / 1000);\n\n        // Проверка на зависание: перезапуск при отсутствии активности более 2 минут\n        if (GlobalVariables.tg_last_active && (now - GlobalVariables.tg_last_active > 120)) {\n            log.warn(\"[\" + logId++ + \"] No activity for 2 minutes, restarting tgWatch at \" + new Date().toISOString());\n            GlobalVariables.tg_loop_running = false;\n            clearInterval(GlobalVariables.tg_loop);\n            GlobalVariables.tg_loop = null;\n            GlobalVariables.tg_lock = false;\n            tgWatch();\n            return;\n        }\n\n        // Очистка старых записей в processedUpdates (старше 48 часов)\n        if (now - GlobalVariables.tg_last_reset >= 3600) {\n            GlobalVariables.tg_last_reset = now;\n            // Лог очистки старых записей processedUpdates с временем. (Для чего: Проверяет очистку обработанных данных.)\n            //log.info(\"[\" + logId++ + \"] Cleaning old processedUpdates at \" + new Date().toISOString());\n            for (let id in GlobalVariables.processedUpdates) {\n                if (now - GlobalVariables.processedUpdates[id] > 48 * 3600) {\n                    delete GlobalVariables.processedUpdates[id];\n                }\n            }\n        }\n\n        let offset = GlobalVariables.__tg_offset;\n\n        // Запрос новых сообщений из Telegram API\n        let body = HttpClient.GET(\"https://api.telegram.org\")\n            .path(\"bot\" + token)\n            .path('getUpdates')\n            .queryString('offset', offset)\n            .send()\n            .getBody();\n\n        if (!body) {\n            log.error(\"[\" + logId++ + \"] No response from Telegram API, body is null\");\n            GlobalVariables.tg_loop_running = false;\n            clearInterval(GlobalVariables.tg_loop);\n            GlobalVariables.tg_loop = null;\n            GlobalVariables.tg_lock = false;\n            return;\n        }\n\n        try {\n            let response = JSON.parse(body);\n            let updates = response.result || [];\n\n            // Лог количества обновлений и offset с временем. (Для чего: Отслеживает активность API.) \n            //log.info(\"[\" + logId++ + \"] Processing \" + updates.length + \" updates at \" + new Date().toISOString() + \", offset: \" + offset);\n            updates.forEach(function(r) {\n                let updateId = r.update_id;\n                // Лог проверки обновлений с updateId и offset. (Для чего: Отслеживает каждое проверяемое обновление.)\n                //log.info(\"[\" + logId++ + \"] Checking update: updateId = \" + updateId + \", offset = \" + offset);\n                if (updateId < offset) {\n                    // Лог пропуска обновлений с updateId меньше offset. (Для чего: Проверяет фильтрацию старых обновлений.)\n                    //log.info(\"[\" + logId++ + \"] Skipping update: updateId \" + updateId + \" is less than offset \" + offset);\n                    return;\n                }\n                if (GlobalVariables.processedUpdates[updateId]) {\n                    // Лог пропуска обработанного обновления с временем. (Для чего: Подтверждает предотвращение дублирования.)\n                    //log.info(\"[\" + logId++ + \"] Skipping update: updateId \" + updateId + \" already processed at \" + new Date(GlobalVariables.processedUpdates[updateId] * 1000).toISOString());\n                    return;\n                }\n                GlobalVariables.__tg_offset = updateId + 1;\n\n                let message = r.message || r.channel_post;\n                if (!message) {\n                    log.warn(\"[\" + logId++ + \"] Skipping update: No message or channel_post in update, full response: \" + JSON.stringify(r) + \", updateId = \" + updateId);\n                    return;\n                }\n\n                let chatId = message.chat.id.toString();\n                // Лог ID чата и ожидаемый sourceChatID. (Для чего: Проверяет источник сообщения.) \n                //log.info(\"[\" + logId++ + \"] Message chatId: \" + chatId + \", expected sourceChatID: \" + sourceChatID);\n                if (chatId !== sourceChatID) {\n                    // Лог пропуска сообщения с неверным chatId. (Для чего: Подтверждает фильтрацию чатов.)\n                    //log.info(\"[\" + logId++ + \"] Skipping update: chatId \" + chatId + \" does not match expected \" + sourceChatID);\n                    return;\n                }\n\n                let messageTime = message.date;\n                // Лог временного параметра сообщения. (Для чего: Отслеживает фильтрацию по времени.)\n                //log.info(\"[\" + logId++ + \"] Debug: messageTime = \" + messageTime + \", now = \" + now + \", startTime = \" + startTime + \", updateId = \" + updateId);\n                if (messageTime < startTime || (now - messageTime) > 600) {\n                    // Лог игнорирования сообщения как слишком старого с текстом, временем отправки и updateId. (Для чего: Проверяет фильтрацию сообщений старше 10 минут.)\n                    //log.warn(\"[\" + logId++ + \"] Message too old, ignoring: \" + (message.text || \"no text\") + \" (sent at \" + new Date(messageTime * 1000).toISOString() + \"), updateId = \" + updateId);\n                    return;\n                }\n\n                let messageText = message.text ? message.text.trim() : '';\n                // Лог Текста сообщения и updateId. (Для чего: Проверяет входящие сообщения.)\n                //log.info(\"[\" + logId++ + \"] Received message: '\" + messageText + \"', updateId = \" + updateId);\n\n                if (messageText) {\n                    let parts = messageText.split(' ');\n                    if (parts.length >= 2) {\n                        let name = parts[0];\n                        let command = parts[1].toLowerCase();\n\n                        // === Настройки пользователей и аксессуаров ===\n                        // Маппинг имён пользователей к их аксессуарам (выключателям).\n                        // Каждый пользователь связан с уникальным accessoryId.\n                        // Можно менять: добавляйте новых пользователей в формате 'Имя': { accessoryId: НОМЕР }, где НОМЕР — ID вашего устройства.\n                        // Пример добавления: 'Олег': { accessoryId: 183 }.\n                        const switchMap = {\n                            'Толя': { accessoryId: 179 },   // Толя, её аксессуар (выключатель)\n                            'Галя': { accessoryId: 180 },  // Галя, её аксессуар\n                            'Лена': { accessoryId: 181 },  // Лена, её аксессуар\n                            'Вася': { accessoryId: 182 }     // Вася, его аксессуар\n                        };\n\n                        if (switchMap[name]) {\n                            let switchAccessory = Hub.getAccessory(switchMap[name].accessoryId);\n                            if (switchAccessory) {\n                                let switchService = switchAccessory.getService(16);\n                                if (switchService) {\n                                    let onCharacteristic = switchService.getCharacteristic(18);\n                                    if (onCharacteristic) {\n                                        let switchState = command === \"arrived\"; // true для arrived, false для left\n                                        onCharacteristic.setValue(switchState); // Устанавливает состояние выключателя\n                                        if (command === \"arrived\") {\n                                            tg().line(name + \" дома\").send();\n                                        } else if (command === \"left\") {\n                                            tg().line(name + \" не дома\").send();\n                                        }\n                                        // Лог обработки выключателя для пользователя. (Для чего: Подтверждает работу выключателей.)\n                                        //log.info(\"[\" + logId++ + \"] Switch processed for \" + name + \", updateId = \" + updateId);\n                                    } else {\n                                        log.error(\"[\" + logId++ + \"] Characteristic 18 not found for service 16 on accessory \" + switchMap[name].accessoryId);\n                                    }\n                                } else {\n                                    log.error(\"[\" + logId++ + \"] Service 16 not found for accessory \" + switchMap[name].accessoryId);\n                                }\n                            } else {\n                                log.error(\"[\" + logId++ + \"] Accessory \" + switchMap[name].accessoryId + \" not found\");\n                            }\n                        } else {\n                            log.error(\"[\" + logId++ + \"] Unknown name: \" + name);\n                        }\n                    } else {\n                        log.warn(\"[\" + logId++ + \"] Message format invalid, expected 'Name command', got: \" + messageText);\n                    }\n                } else {\n                    // Лог пропуска сообщения без текста. (Для чего: Проверяет фильтрацию пустых сообщений.)\n                    //log.info(\"[\" + logId++ + \"] Skipping message: No text in message, updateId = \" + updateId);\n                }\n                GlobalVariables.processedUpdates[updateId] = now; // Отмечаем обновление как обработанное\n            });\n            GlobalVariables.tg_last_active = now; // Обновляем время последней активности\n        } catch (e) {\n            log.error(\"[\" + logId++ + \"] Error parsing API response: \" + e.message);\n            GlobalVariables.tg_loop_running = false;\n            clearInterval(GlobalVariables.tg_loop);\n            GlobalVariables.tg_loop = null;\n            GlobalVariables.tg_lock = false;\n        }\n    };\n\n    // Запускаем цикл с интервалом 5 секунд\n    // Интервал 5000 мс (5 секунд) обеспечивает своевременную обработку сообщений\n    // Можно менять: увеличьте (например, 10000 для 10 секунд) для снижения нагрузки, но это может замедлить реакцию.\n    GlobalVariables.tg_loop = setInterval(loop, 5000);\n    GlobalVariables.tg_last_active = Math.floor(Date.now() / 1000); // Инициализация времени активности\n    // Лог запуска цикла tgWatch с временем. (Для чего: Подтверждает старт цикла.)\n    log.info(\"[\" + logId++ + \"] tgWatch started with interval at \" + new Date().toISOString());\n    GlobalVariables.tg_lock = false; // Освобождаем блокировку после запуска\n}",
    "type": "GLOBAL"
  }
}