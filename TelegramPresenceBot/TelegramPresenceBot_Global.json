{
  "scenarioTemplate": {
    "name": "TelegramPresenceBot",
    "desc": "",
    "active": true,
    "onStart": false,
    "sync": false,
    "data": "// Глобальный сценарий: TelegramPresenceBot\n// Этот скрипт отслеживает присутствие пользователей дома или вне дома через Telegram.\n// Обрабатывает сообщения вида \"Имя arrived\" или \"Имя left\" из канала, управляет выключателями и отправляет уведомления в группу.\n// Например: \"Толя arrived\" включает выключатель и отправляет \"Толя дома\", \"Толя left\" — \"Толя не дома\".\n// Основан на Telegram Bot API (см. документацию: https://core.telegram.org/bots/api).\n\n// === Настройки чата и бота ===\n// ID канала, откуда приходят сообщения (например, \"ProxyFamily\").\n// Узнать ID канала можно через @RawDataBot в Telegram (отправьте /start и посмотрите chat_id в ответе).\n// Нужно заменить: '***твой_ид_канала***' на ID вашего канала. Убедитесь, что бот добавлен в канал с правами чтения.\nlet sourceChatID = '***твой_ид_канала***'; // ID канала, откуда приходят сообщения\n\n// ID группы или групп, куда бот будет отправлять ответы (например, \"Семья\").\n// Нужно заменить: '***твой_ид_группы***' на ID вашей группы. Для нескольких групп добавьте новые ID в массив, например: ['-1007777777777', '-100555555555'].\nlet replyChatIDs = ['***твой_ид_группы***']; // ID группы \"Семья\" для ответов\n\n// Токен бота, полученный от @BotFather в Telegram после регистрации бота.\n// Это секретный ключ, не делитесь им! Храните в безопасном месте (например, в переменной окружения).\n// Вставьте свой токен вместо: '***твой_токен***'. Если токен неверный, бот не сможет работать.\nlet token = '***твой_токен***'; // Токен бота\n\n// Начальное время для обработки сообщений (минус 48 часов от текущего времени).\n// Определяет, какие сообщения считаются \"слишком старыми\" и игнорируются (например, старше 48 часов).\n// Можно менять: измените 48 на другое значение (например, 24 для 24 часов), если нужен другой период обработки.\nlet startTime = Math.floor(Date.now() / 1000) - 48 * 3600; // Начало времени минус 48 часов\n\n// Режим отладки для включения подробного логирования.\n// Можно менять: установите true для включения или false для отключения (рекомендуется true для диагностики).\nlet debugMode = false; // Включено для отладки, можно переключить на false после стабилизации\n\n// Уникальный номер для логов, увеличивается автоматически при каждом действии.\n// Используется для отслеживания последовательности событий в логах.\n// Нельзя менять: это нужно для корректной работы логов и их читаемости. После отладки можно закомментировать увеличение logId.\nlet logId = GlobalVariables.logId || 0;\nGlobalVariables.logId = logId; // Сохраняем текущее значение\n\n// Флаг, показывающий, работает ли цикл tgWatch.\n// Используется для предотвращения параллельных запусков цикла.\n// Нельзя менять: это часть механизма управления циклом.\nGlobalVariables.tg_loop_running = GlobalVariables.tg_loop_running || false;\n\n// Флаг блокировки для защиты от параллельных запусков.\n// Используется для синхронизации при одновременном срабатывании триггеров.\n// Нельзя менять: это часть защиты от конфликтов.\nGlobalVariables.tg_lock = GlobalVariables.tg_lock || false;\n\n// Хранит идентификатор текущего таймера для цикла tgWatch.\n// Используется для управления и очистки цикла при перезапуске.\n// Нельзя менять: нужно для корректной работы цикла.\nGlobalVariables.tg_loop = null;\n\n// Время последнего сброса старых данных (в секундах от эпохи).\n// Используется для очистки старых записей в processedUpdates раз в час.\n// Нельзя менять вручную: обновляется автоматически.\nGlobalVariables.tg_last_reset = GlobalVariables.tg_last_reset || 0;\n\n// Время последней активности цикла (в секундах от эпохи).\n// Используется для проверки зависаний (перезапуск при отсутствии активности более 2 минут).\n// Нельзя менять вручную: обновляется автоматически.\nGlobalVariables.tg_last_active = GlobalVariables.tg_last_active || 0;\n\n// Смещение для запросов Telegram API.\n// Определяет, с какого сообщения начинать обработку.\n// Нельзя менять вручную: обновляется автоматически.\nGlobalVariables.__tg_offset = GlobalVariables.__tg_offset || 0;\n\n// Объект для хранения обработанных update_id с меткой времени.\n// Предотвращает повторную обработку сообщений.\n// Нельзя менять структуру: добавляется автоматически.\nGlobalVariables.processedUpdates = GlobalVariables.processedUpdates || {};\n\n// Функция для отправки сообщений в Telegram.\n// Формирует и отправляет ответы в указанные чаты (например, \"Галя дома\") через Bot API.\n// Нельзя менять: это базовая функция для взаимодействия с Telegram.\nfunction tg() {\n    let chats = [];\n    let messages = [];\n    let silent = false;\n\n    var builder = {\n        line: function(text) {\n            messages.push(text); // Добавляет текст сообщения\n            return builder;\n        },\n        silent: function(enabled) {\n            silent = enabled !== undefined ? enabled : true; // Включает/выключает уведомления\n            return builder;\n        },\n        send: function() {\n            if (!chats.length) chats = replyChatIDs; // Использует replyChatIDs, если чаты не указаны\n            chats.forEach(function(chatID) {\n                try {\n                    // Лог отправки (можно закомментировать после отладки)\n                    // Лог: Отображает отправку сообщения в указанный чат с ID и временем. Зачем: Проверяет успешность отправки.\n                    //log.info(\"[\" + logId++ + \"] Sending message to chat: \" + chatID + \" at \" + new Date().toISOString());\n                    let request = HttpClient.POST(\"https://api.telegram.org\")\n                        .path(\"bot\" + token)\n                        .path('sendMessage')\n                        .queryString('chat_id', chatID)\n                        .queryString('text', messages.join(\" \\r\\n\"))\n                        .queryString(\"parse_mode\", \"Markdown\")\n                        .queryString(\"disable_notification\", silent);\n                    request.send();\n                } catch (e) {\n                    log.error(\"[\" + logId++ + \"] Send error: \" + e.message + \" at \" + new Date().toISOString());\n                }\n            });\n        }\n    };\n    return builder;\n}\n\n// Основная функция проверки сообщений из Telegram.\n// Запускает цикл с динамическим интервалом для обработки новых сообщений через getUpdates.\n// Обрабатывает команды вида \"Имя arrived\" или \"Имя left\".\nfunction tgWatch() {\n    // Проверяем блокировку перед запуском\n    if (GlobalVariables.tg_lock) {\n        log.warn(\"[\" + logId++ + \"] tgWatch is locked, skipping start at \" + new Date().toISOString());\n        return;\n    }\n    GlobalVariables.tg_lock = true;\n    // Лог: Отображает получение блокировки и запуск tgWatch. Зачем: Подтверждает начало работы цикла.\n    //log.info(\"[\" + logId++ + \"] Acquired tg_lock, starting tgWatch\");\n\n    // Очищаем старый цикл\n    if (GlobalVariables.tg_loop && !GlobalVariables.tg_loop._destroyed) { // Добавлена проверка состояния таймера\n        clearInterval(GlobalVariables.tg_loop);\n        GlobalVariables.tg_loop = null;\n        // Лог: Отображает очистку старого таймера tg_loop с временем. Зачем: Проверяет завершение предыдущих циклов.\n        //log.info(\"[\" + logId++ + \"] Forced cleanup of old tg_loop timer at \" + new Date().toISOString());\n    }\n    if (GlobalVariables.tg_loop_running) {\n        GlobalVariables.tg_loop_running = false;\n        // Лог: Отображает сброс флага tg_loop_running с временем. Зачем: Подтверждает сброс состояния.\n        //log.info(\"[\" + logId++ + \"] Forced reset of tg_loop_running at \" + new Date().toISOString());\n    }\n\n    // Сбрасываем смещение для обработки новых сообщений\n    GlobalVariables.__tg_offset = 0;\n    // Лог: Отображает сброс смещения __tg_offset с временем. Зачем: Проверяет начальное получение обновлений.\n    //log.info(\"[\" + logId++ + \"] Reset __tg_offset to 0 at \" + new Date().toISOString());\n\n    // Сбрасываем logId при превышении\n    if (logId > 100000) {\n        logId = 0;\n        GlobalVariables.logId = 0;\n        // Лог: Отображает сброс logId до 0 с временем. Зачем: Поддерживает читаемость логов.\n        //log.info(\"[\" + logId++ + \"] logId reset to 0 at \" + new Date().toISOString());\n    }\n\n    // Устанавливаем флаг запуска цикла перед началом работы\n    GlobalVariables.tg_loop_running = true;\n\n    // Основной цикл проверки сообщений\n    let loop = function() {\n        if (!GlobalVariables.tg_loop_running) {\n            log.warn(\"[\" + logId++ + \"] tg_loop_running is false, stopping loop at \" + new Date().toISOString());\n            clearInterval(GlobalVariables.tg_loop);\n            GlobalVariables.tg_loop = null;\n            GlobalVariables.tg_lock = false;\n            return;\n        }\n\n        let now = Math.floor(Date.now() / 1000);\n\n        // Проверка на зависание (2 минуты без активности)\n        if (GlobalVariables.tg_last_active && (now - GlobalVariables.tg_last_active > 120)) {\n            log.warn(\"[\" + logId++ + \"] No activity for 2 minutes, restarting tgWatch at \" + new Date().toISOString());\n            GlobalVariables.tg_loop_running = false;\n            clearInterval(GlobalVariables.tg_loop);\n            GlobalVariables.tg_loop = null;\n            GlobalVariables.tg_lock = false;\n            global.tgWatch();\n            return;\n        }\n\n        // Очистка старых записей processedUpdates\n        if (now - GlobalVariables.tg_last_reset >= 3600) {\n            GlobalVariables.tg_last_reset = now;\n            // Лог: Отображает очистку старых записей processedUpdates с временем. Зачем: Проверяет удаление устаревших данных.\n            //log.info(\"[\" + logId++ + \"] Cleaning old processedUpdates at \" + new Date().toISOString());\n            for (let id in GlobalVariables.processedUpdates) {\n                if (now - GlobalVariables.processedUpdates[id] > 48 * 3600) {\n                    delete GlobalVariables.processedUpdates[id];\n                }\n            }\n        }\n\n        let offset = GlobalVariables.__tg_offset;\n\n        // Запрос новых сообщений\n        let body = HttpClient.GET(\"https://api.telegram.org\")\n            .path(\"bot\" + token)\n            .path('getUpdates')\n            .queryString('offset', String(offset))\n            .send()\n            .getBody();\n\n        if (!body) {\n            log.error(\"[\" + logId++ + \"] No response from Telegram API, body is null at \" + new Date().toISOString());\n            // Повторная попытка с экспоненциальной задержкой\n            setTimeout(() => global.tgWatch(), 5000); // Повтор через 5 секунд\n            GlobalVariables.tg_loop_running = false;\n            clearInterval(GlobalVariables.tg_loop);\n            GlobalVariables.tg_loop = null;\n            GlobalVariables.tg_lock = false;\n            return;\n        }\n\n        try {\n            let response = JSON.parse(body);\n            let updates = response.result || [];\n\n            // Лог: Отображает обработку обновлений с количеством и временем. Зачем: Отслеживает активность API.\n            if (debugMode) log.info(\"[\" + logId++ + \"] Processing \" + updates.length + \" updates at \" + new Date().toISOString());\n            updates.forEach(function(r) {\n                let updateId = r.update_id;\n                if (updateId < offset || GlobalVariables.processedUpdates[updateId]) {\n                    return;\n                }\n                GlobalVariables.__tg_offset = updateId + 1;\n\n                let message = r.message || r.channel_post;\n                if (!message || message.chat.id.toString() !== sourceChatID) {\n                    return;\n                }\n\n                let messageTime = message.date;\n                if (messageTime < startTime || (now - messageTime) > 600) {\n                    // Лог: Отображает игнорирование старых сообщений с текстом и временем. Зачем: Проверяет фильтрацию.\n                    //log.warn(\"[\" + logId++ + \"] Message too old, ignoring: \" + (message.text || \"no text\"));\n                    return;\n                }\n\n                let messageText = message.text ? message.text.trim() : '';\n                if (messageText) {\n                    let parts = messageText.split(' ');\n                    if (parts.length >= 2) {\n                        let name = parts[0];\n                        let command = parts[1].toLowerCase();\n\n                        // === Настройки пользователей и аксессуаров ===\n                        // Маппинг имён пользователей к их аксессуарам (выключателям).\n                        // Каждый пользователь связан с уникальным accessoryId.\n                        // Можно менять: добавляйте новых пользователей в формате 'Имя': { accessoryId: НОМЕР }, где НОМЕР — ID вашего устройства.\n                        // Пример добавления: 'Олег': { accessoryId: 183 }.\n                        const switchMap = {\n                            'Толя': { accessoryId: 179 },  // Толя, её аксессуар (выключатель)\n                            'Вася': { accessoryId: 180 }, // Вася, её аксессуар\n                            'Лена': { accessoryId: 181 }, // Лена, её аксессуар\n                            'Галя': { accessoryId: 182 }    // Галя, его аксессуар\n                        };\n\n                        if (switchMap[name]) {\n                            let switchAccessory = Hub.getAccessory(switchMap[name].accessoryId);\n                            if (switchAccessory) {\n                                let switchService = switchAccessory.getService(16);\n                                if (switchService) {\n                                    let onCharacteristic = switchService.getCharacteristic(18);\n                                    if (onCharacteristic) {\n                                        let switchState = command === \"arrived\"; // true для arrived, false для left\n                                        onCharacteristic.setValue(switchState);  // Устанавливает состояние выключателя\n                                        if (command === \"arrived\") {\n                                            tg().line(name + \" дома\").send();\n                                        } else if (command === \"left\") {\n                                            tg().line(name + \" не дома\").send();\n                                        }\n                                        // Лог: Отображает обработку выключателя для пользователя. Зачем: Подтверждает работу.\n                                        //log.info(\"[\" + logId++ + \"] Switch processed for \" + name);\n                                    } else {\n                                        log.error(\"[\" + logId++ + \"] Characteristic 18 not found for accessory \" + switchMap[name].accessoryId);\n                                    }\n                                } else {\n                                    log.error(\"[\" + logId++ + \"] Service 16 not found for accessory \" + switchMap[name].accessoryId);\n                                }\n                            } else {\n                                log.error(\"[\" + logId++ + \"] Accessory \" + switchMap[name].accessoryId + \" not found\");\n                            }\n                        } else {\n                            log.error(\"[\" + logId++ + \"] Unknown name: \" + name);\n                        }\n                    } else {\n                        log.warn(\"[\" + logId++ + \"] Invalid message format: \" + messageText);\n                    }\n                }\n                GlobalVariables.processedUpdates[updateId] = now;\n            });\n            GlobalVariables.tg_last_active = now;\n        } catch (e) {\n            log.error(\"[\" + logId++ + \"] Error parsing API response: \" + e.message + \" at \" + new Date().toISOString());\n            GlobalVariables.tg_loop_running = false;\n            clearInterval(GlobalVariables.tg_loop);\n            GlobalVariables.tg_loop = null;\n            GlobalVariables.tg_lock = false;\n        }\n    };\n\n    // Запускаем цикл с динамическим интервалом\n    // Интервал адаптируется: 5 сек при активности, 10 сек при бездействии\n    let interval = (GlobalVariables.tg_last_active && (Math.floor(Date.now() / 1000) - GlobalVariables.tg_last_active < 60)) ? 5000 : 10000;\n    GlobalVariables.tg_loop = setInterval(loop, interval);\n    GlobalVariables.tg_last_active = Math.floor(Date.now() / 1000);\n    // Лог: Подтверждает запуск цикла tgWatch с указанием времени. Зачем: Указывает, что tgWatch успешно стартовал.\n    //log.info(\"[\" + logId++ + \"] tgWatch started with interval at \" + new Date().toISOString());\n    GlobalVariables.tg_lock = false;\n}\n\n// Функция перезапуска tgWatch.\n// Очищает состояние и запускает tgWatch заново.\nfunction restartTg() {\n    // Пропускаем ручной запуск через WEB[RPC]\n    if (typeof TriggerSource !== 'undefined' && TriggerSource === 'WEB[RPC]') {\n        // Лог: Отображает обнаружение ручного запуска через WEB[RPC] с указанием времени. Зачем: Подтверждает, что перезапуск tgWatch пропущен при ручном вызове.\n        log.info(\"Manual trigger via WEB[RPC] detected, skipping restart at \" + new Date().toISOString());\n        return;\n    }\n    // Остановка старого цикла\n    if (GlobalVariables.tg_loop && !GlobalVariables.tg_loop._destroyed) {\n        clearInterval(GlobalVariables.tg_loop);\n        GlobalVariables.tg_loop = null;\n        GlobalVariables.tg_loop_running = false;\n        // Лог: Отображает остановку существующего цикла. Зачем: Подтверждает завершение.\n        //log.info(\"[\" + logId++ + \"] Stopping existing code\");\n    } else {\n        GlobalVariables.tg_loop_running = false;\n    }\n    // Сохраняем важные переменные\n    let savedLogId = GlobalVariables.logId || 0;\n    let savedOffset = GlobalVariables.__tg_offset || 0;\n    let savedProcessedUpdates = GlobalVariables.processedUpdates || {};\n    let savedLastActive = GlobalVariables.tg_last_active || 0;\n    // Сбрасываем\n    GlobalVariables = {};\n    // Восстанавливаем\n    GlobalVariables.logId = savedLogId;\n    GlobalVariables.__tg_offset = savedOffset;\n    GlobalVariables.processedUpdates = savedProcessedUpdates;\n    GlobalVariables.tg_last_active = savedLastActive;\n    // Запуск\n    global.tgWatch();\n    // Лог: Подтверждает вызов функции tgWatch. Зачем: Указывает, что tgWatch был вызван (например, после перезапуска).\n    //log.info(\"tgWatch called at \" + new Date().toISOString());\n}\n\n// Регистрируем функции\nglobal.tgWatch = tgWatch;\nglobal.restartTg = restartTg;\n\n// === Новая функция для ручного запуска цикла ===\n// Функция: Выполняет ручной запуск цикла tgWatch для немедленного начала работы.\n// Использование: Вызывается вручную через WEB[RPC] или другой триггер для перезапуска цикла.\n// Можно менять: Нет, это вспомогательная функция для удобства.\n// Лог: Подтверждает ручной запуск tgWatch с указанием времени. Зачем: Указывает на успешный старт цикла по запросу пользователя. Можно комментировать: Да, если ручной запуск больше не нужен.\nfunction manualStartTgWatch() {\n    // Пропускаем ручной запуск через WEB[RPC], чтобы сохранить защиту\n    if (typeof TriggerSource !== 'undefined' && TriggerSource === 'WEB[RPC]') {\n        // Лог: Отображает обнаружение ручного запуска через WEB[RPC] с указанием времени. Зачем: Подтверждает, что запуск tgWatch пропущен.\n        log.info(\"Manual trigger via WEB[RPC] detected, skipping manual start at \" + new Date().toISOString());\n        return;\n    }\n    global.tgWatch();\n    log.info(\"Manually started tgWatch at \" + new Date().toISOString());\n}\n\nglobal.manualStartTgWatch = manualStartTgWatch;",
    "type": "GLOBAL"
  }
}